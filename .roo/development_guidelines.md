# Гайдлайны по разработке

## Введение
Четкие гайдлайны по разработке — это фундамент качественного и поддерживаемого продукта. Они помогают команде работать слаженно, уменьшают количество ошибок и упрощают онбординг новых участников.

## Контроль версий (Git)

### Правила именования веток
Для единообразия и понятности истории изменений, придерживайтесь следующих правил именования веток:
*   **`feature/название-фичи`**: для разработки новой функциональности (например, `feature/user-authentication`).
*   **`bugfix/номер-бага-или-описание`**: для исправления ошибок (например, `bugfix/login-error-502` или `bugfix/fix-button-display`).
*   **`hotfix/описание-фикса`**: для срочных исправлений в продакшене (например, `hotfix/critical-payment-issue`).
*   **`refactor/область-рефакторинга`**: для улучшения существующего кода без изменения функциональности (например, `refactor/api-service-optimization`).
*   **`docs/тема-документации`**: для написания или обновления документации (например, `docs/update-api-usage`).
*   **`chore/описание-задачи`**: для задач, не связанных с кодом напрямую (настройка CI, обновление зависимостей и т.д.) (например, `chore/update-docker-config`).

### Семантические сообщения коммитов
Сообщения коммитов должны быть информативными и следовать семантическому версионированию. Это упрощает чтение истории и автоматическую генерацию списков изменений (changelogs).
Структура: `<тип>(<область>): <краткое описание>`
*   **`feat`**: новая функциональность.
    *   Пример: `feat(auth): добавлена аутентификация через OAuth2`
*   **`fix`**: исправление бага.
    *   Пример: `fix(ui): исправлена ошибка отображения кнопки на мобильных устройствах`
*   **`docs`**: изменения в документации.
    *   Пример: `docs(readme): обновлено описание установки проекта`
*   **`style`**: исправления, не влияющие на логику кода (пробелы, форматирование, точки с запятой и т.д.).
    *   Пример: `style(core): исправлены отступы в главном модуле`
*   **`refactor`**: изменения кода, которые не исправляют баг и не добавляют новую фичу.
    *   Пример: `refactor(services): оптимизирован запрос к базе данных`
*   **`perf`**: изменения, улучшающие производительность.
    *   Пример: `perf(images): добавлено ленивая загрузка изображений`
*   **`test`**: добавление или исправление тестов.
    *   Пример: `test(user): написаны unit-тесты для сервиса пользователей`
*   **`build`**: изменения, влияющие на систему сборки или внешние зависимости (например, Gulp, Webpack, NPM).
    *   Пример: `build(deps): обновлена версия библиотеки React до 18.2.0`
*   **`ci`**: изменения в файлах и скриптах конфигурации CI (например, Travis, Circle, BrowserStack, SauceLabs).
    *   Пример: `ci(jenkins): исправлена ошибка в пайплайне сборки`
*   **`chore`**: прочие изменения, не модифицирующие исходный код или тесты (например, изменения в `.gitignore`).
    *   Пример: `chore: обновлен .gitignore для исключения логов`

### Процесс Pull Request (PR) / Merge Request (MR)
1.  **Создание PR**: После завершения работы в своей ветке, создайте Pull Request в основную ветку разработки (например, `main`, `develop`).
2.  **Описание PR**: В описании PR четко укажите, какие изменения были сделаны, какую проблему они решают, и как их можно протестировать. Ссылайтесь на связанные задачи в таск-трекере.
3.  **Ревью кода**:
    *   Как минимум один другой разработчик (или `Architect` для значительных изменений) должен провести ревью кода.
    *   Ревьюер проверяет код на соответствие гайдлайнам, наличие багов, качество архитектуры и читаемость.
    *   Все замечания должны быть конструктивными и обсуждаться в комментариях к PR.
4.  **CI/CD проверки**:
    *   Все автоматические проверки (линтеры, тесты, сборка) должны успешно проходить перед мержем.
    *   Если проверки не прошли, автор PR должен исправить проблемы.
5.  **Мерж**: После успешного ревью и прохождения всех проверок, PR может быть смержен в основную ветку. Предпочтительно использовать squash merge для чистоты истории основной ветки, если это принято в проекте.

## Стиль кода
*   **Чистота и читаемость**: Код должен быть легко читаемым и понятным. Используйте осмысленные имена переменных, функций и классов. Избегайте излишне сложных конструкций.
*   **DRY (Don't Repeat Yourself)**: Избегайте дублирования кода. Выносите повторяющиеся участки в функции или классы.
*   **KISS (Keep It Simple, Stupid)**: Предпочитайте простые решения сложным.
*   **SOLID**: Принципы объектно-ориентированного дизайна, если применимо к используемому языку/фреймворку.
*   **Линтеры и форматеры**: Используйте настроенные для проекта линтеры (например, ESLint для JavaScript, Pylint/Flake8 для Python, RuboCop для Ruby) и форматеры (Prettier, Black, etc.). Это обеспечивает единообразие стиля кода во всем проекте. Конфигурации линтеров и форматеров должны быть частью репозитория.
*   **Комментарии**: Комментируйте неочевидные участки кода. Комментарии должны объяснять *почему* код написан так, а не *что* он делает (это должно быть понятно из самого кода).

## Тестирование

### Важность написания unit-тестов
*   Unit-тесты проверяют работоспособность отдельных модулей и функций в изоляции.
*   Они помогают обнаруживать ошибки на ранних стадиях разработки.
*   Облегчают рефакторинг, так как позволяют убедиться, что изменения не сломали существующую функциональность.
*   Стремитесь к высокому покрытию кода unit-тестами.

### Подход к интеграционным тестам
*   Интеграционные тесты проверяют взаимодействие между различными компонентами системы (например, взаимодействие сервиса с базой данных, или между несколькими микросервисами).
*   Они более сложные и медленные, чем unit-тесты, но важны для проверки корректной работы системы в целом.

### E2E-тесты (End-to-End)
*   E2E-тесты симулируют поведение реального пользователя, проверяя всю систему от пользовательского интерфейса до бэкенда.
*   Они наиболее затратны в написании и поддержке, но дают наибольшую уверенность в работоспособности приложения.
*   Используйте их для проверки критически важных пользовательских сценариев.

## Документирование кода
*   **Комментарии в коде**: Как уже упоминалось, комментируйте сложные или неочевидные части кода.
*   **Docstrings/JSDoc/etc.**: Для функций, классов, методов и модулей пишите документационные строки в соответствии со стандартами языка (например, JSDoc для JavaScript, docstrings для Python). Это позволяет автоматически генерировать документацию.
*   **API документация**: Если проект предоставляет API, оно должно быть тщательно документировано. Используйте инструменты вроде Swagger/OpenAPI для описания эндпоинтов, параметров запросов, форматов ответов и кодов ошибок.
*   **README.md**: Каждый проект/микросервис должен иметь `README.md` файл с описанием проекта, инструкциями по установке, запуску, тестированию и деплою.

## Обработка ошибок и логирование

### Стандарты логирования
*   **Уровни логирования**: Используйте стандартные уровни логирования (DEBUG, INFO, WARNING, ERROR, CRITICAL) для классификации сообщений.
    *   `DEBUG`: Детальная информация для отладки.
    *   `INFO`: Общая информация о работе приложения (например, запуск сервиса, успешное выполнение операции).
    *   `WARNING`: Нештатные ситуации, которые не приводят к остановке работы, но требуют внимания.
    *   `ERROR`: Ошибки, которые привели к сбою выполнения конкретной операции, но приложение продолжает работать.
    *   `CRITICAL`: Критические ошибки, которые могут привести к остановке всего приложения.
*   **Формат логов**: Логи должны быть структурированы (например, в JSON формате) и содержать полезную информацию: временную метку, уровень логирования, сообщение, контекст (например, ID пользователя, ID запроса, имя модуля/функции).
*   **Конфиденциальность**: Не логируйте чувствительные данные (пароли, токены, персональные данные) в открытом виде.

### Обработка исключений
*   **Явная обработка**: Не игнорируйте исключения. Обрабатывайте их явно с помощью `try-catch` (или аналогов в вашем языке).
*   **Специфичные исключения**: Создавайте и используйте специфичные классы исключений для разных типов ошибок. Это упрощает их обработку и понимание.
*   **Не перехватывайте слишком общие исключения**: Избегайте перехвата базовых классов исключений (вроде `Exception` в Python или Java), если вы не знаете точно, как их обработать.
*   **Сообщения об ошибках**: Сообщения об ошибках должны быть информативными и помогать в диагностике проблемы.